// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: livesplit/connect/v1/livesplit.proto

package connectv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LiveSplitServiceClient is the client API for LiveSplitService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LiveSplitServiceClient interface {
	// StartOrSplit starts the timer if not start, or split current segment is the timer is started.
	// If the timer is paused, nothing happens.
	StartOrSplit(ctx context.Context, in *StartOrSplitRequest, opts ...grpc.CallOption) (*StartOrSplitResponse, error)
	// SkipSplit skip current split and move timer to the next segment.
	// If the timer is not started, this command does nothing.
	SkipSplit(ctx context.Context, in *SkipSplitRequest, opts ...grpc.CallOption) (*SkipSplitResponse, error)
	// UnSplit undoes current split and move timer to the previous segment.
	// If the timer is not started, this command does nothing.
	UnSplit(ctx context.Context, in *UnSplitRequest, opts ...grpc.CallOption) (*UnSplitResponse, error)
	// Pause toogles pause on the timer (pause if started, unpause if paused).
	// If the timer is not started, this command does nothing.
	Pause(ctx context.Context, in *PauseRequest, opts ...grpc.CallOption) (*PauseResponse, error)
	// Reset the timer and all current segment splits.
	Reset(ctx context.Context, in *ResetRequest, opts ...grpc.CallOption) (*ResetResponse, error)
	// GetTime returns the current time information of the timer.
	GetTime(ctx context.Context, in *GetTimeRequest, opts ...grpc.CallOption) (*GetTimeResponse, error)
	// GetCurrentSegment returns the current segment info.
	GetCurrentSegment(ctx context.Context, in *GetCurrentSegmentRequest, opts ...grpc.CallOption) (*GetCurrentSegmentResponse, error)
	// FindSegment searchs for a specific segment in the segment list of the run.
	FindSegment(ctx context.Context, in *FindSegmentRequest, opts ...grpc.CallOption) (*FindSegmentResponse, error)
	// ListSegment returns all segment info of the run.
	ListSegment(ctx context.Context, in *ListSegmentRequest, opts ...grpc.CallOption) (*ListSegmentResponse, error)
	// GetRun returns all information of the run.
	GetRun(ctx context.Context, in *GetRunRequest, opts ...grpc.CallOption) (*GetRunResponse, error)
	// GetCurrentComparisonMethod returns the current select comparaison method in LiveSplit.
	GetCurrentComparisonMethod(ctx context.Context, in *GetCurrentComparisonMethodRequest, opts ...grpc.CallOption) (*GetCurrentComparisonMethodResponse, error)
	// GetCurrentTimerPhase returns the current timer phase in LiveSplit
	GetCurrentTimerPhase(ctx context.Context, in *GetCurrentTimerPhaseRequest, opts ...grpc.CallOption) (*GetCurrentTimerPhaseResponse, error)
	// GetCurrentTimingMethod returns the current selected timing method in LiveSplit.
	GetCurrentTimingMethod(ctx context.Context, in *GetCurrentTimingMethodRequest, opts ...grpc.CallOption) (*GetCurrentTimingMethodResponse, error)
	// WatchTime streams regularly current run time to the client.
	// The frequency of updates is specified in the request.
	WatchTime(ctx context.Context, in *WatchTimeRequest, opts ...grpc.CallOption) (LiveSplitService_WatchTimeClient, error)
	// WatchTimerPhase streams change events regarding timer phase to the client.
	WatchTimerPhase(ctx context.Context, in *WatchTimerPhaseRequest, opts ...grpc.CallOption) (LiveSplitService_WatchTimerPhaseClient, error)
	// WatchSplit streams change events regarding timer phase to the client.
	WatchSplit(ctx context.Context, in *WatchSplitRequest, opts ...grpc.CallOption) (LiveSplitService_WatchSplitClient, error)
	// WatchRun streams change events regarding selected run (ie when another run file is loaded) to the client.
	WatchRun(ctx context.Context, in *WatchRunRequest, opts ...grpc.CallOption) (LiveSplitService_WatchRunClient, error)
}

type liveSplitServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLiveSplitServiceClient(cc grpc.ClientConnInterface) LiveSplitServiceClient {
	return &liveSplitServiceClient{cc}
}

func (c *liveSplitServiceClient) StartOrSplit(ctx context.Context, in *StartOrSplitRequest, opts ...grpc.CallOption) (*StartOrSplitResponse, error) {
	out := new(StartOrSplitResponse)
	err := c.cc.Invoke(ctx, "/livesplit.connect.v1.LiveSplitService/StartOrSplit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveSplitServiceClient) SkipSplit(ctx context.Context, in *SkipSplitRequest, opts ...grpc.CallOption) (*SkipSplitResponse, error) {
	out := new(SkipSplitResponse)
	err := c.cc.Invoke(ctx, "/livesplit.connect.v1.LiveSplitService/SkipSplit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveSplitServiceClient) UnSplit(ctx context.Context, in *UnSplitRequest, opts ...grpc.CallOption) (*UnSplitResponse, error) {
	out := new(UnSplitResponse)
	err := c.cc.Invoke(ctx, "/livesplit.connect.v1.LiveSplitService/UnSplit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveSplitServiceClient) Pause(ctx context.Context, in *PauseRequest, opts ...grpc.CallOption) (*PauseResponse, error) {
	out := new(PauseResponse)
	err := c.cc.Invoke(ctx, "/livesplit.connect.v1.LiveSplitService/Pause", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveSplitServiceClient) Reset(ctx context.Context, in *ResetRequest, opts ...grpc.CallOption) (*ResetResponse, error) {
	out := new(ResetResponse)
	err := c.cc.Invoke(ctx, "/livesplit.connect.v1.LiveSplitService/Reset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveSplitServiceClient) GetTime(ctx context.Context, in *GetTimeRequest, opts ...grpc.CallOption) (*GetTimeResponse, error) {
	out := new(GetTimeResponse)
	err := c.cc.Invoke(ctx, "/livesplit.connect.v1.LiveSplitService/GetTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveSplitServiceClient) GetCurrentSegment(ctx context.Context, in *GetCurrentSegmentRequest, opts ...grpc.CallOption) (*GetCurrentSegmentResponse, error) {
	out := new(GetCurrentSegmentResponse)
	err := c.cc.Invoke(ctx, "/livesplit.connect.v1.LiveSplitService/GetCurrentSegment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveSplitServiceClient) FindSegment(ctx context.Context, in *FindSegmentRequest, opts ...grpc.CallOption) (*FindSegmentResponse, error) {
	out := new(FindSegmentResponse)
	err := c.cc.Invoke(ctx, "/livesplit.connect.v1.LiveSplitService/FindSegment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveSplitServiceClient) ListSegment(ctx context.Context, in *ListSegmentRequest, opts ...grpc.CallOption) (*ListSegmentResponse, error) {
	out := new(ListSegmentResponse)
	err := c.cc.Invoke(ctx, "/livesplit.connect.v1.LiveSplitService/ListSegment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveSplitServiceClient) GetRun(ctx context.Context, in *GetRunRequest, opts ...grpc.CallOption) (*GetRunResponse, error) {
	out := new(GetRunResponse)
	err := c.cc.Invoke(ctx, "/livesplit.connect.v1.LiveSplitService/GetRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveSplitServiceClient) GetCurrentComparisonMethod(ctx context.Context, in *GetCurrentComparisonMethodRequest, opts ...grpc.CallOption) (*GetCurrentComparisonMethodResponse, error) {
	out := new(GetCurrentComparisonMethodResponse)
	err := c.cc.Invoke(ctx, "/livesplit.connect.v1.LiveSplitService/GetCurrentComparisonMethod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveSplitServiceClient) GetCurrentTimerPhase(ctx context.Context, in *GetCurrentTimerPhaseRequest, opts ...grpc.CallOption) (*GetCurrentTimerPhaseResponse, error) {
	out := new(GetCurrentTimerPhaseResponse)
	err := c.cc.Invoke(ctx, "/livesplit.connect.v1.LiveSplitService/GetCurrentTimerPhase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveSplitServiceClient) GetCurrentTimingMethod(ctx context.Context, in *GetCurrentTimingMethodRequest, opts ...grpc.CallOption) (*GetCurrentTimingMethodResponse, error) {
	out := new(GetCurrentTimingMethodResponse)
	err := c.cc.Invoke(ctx, "/livesplit.connect.v1.LiveSplitService/GetCurrentTimingMethod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveSplitServiceClient) WatchTime(ctx context.Context, in *WatchTimeRequest, opts ...grpc.CallOption) (LiveSplitService_WatchTimeClient, error) {
	stream, err := c.cc.NewStream(ctx, &LiveSplitService_ServiceDesc.Streams[0], "/livesplit.connect.v1.LiveSplitService/WatchTime", opts...)
	if err != nil {
		return nil, err
	}
	x := &liveSplitServiceWatchTimeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LiveSplitService_WatchTimeClient interface {
	Recv() (*WatchTimeResponse, error)
	grpc.ClientStream
}

type liveSplitServiceWatchTimeClient struct {
	grpc.ClientStream
}

func (x *liveSplitServiceWatchTimeClient) Recv() (*WatchTimeResponse, error) {
	m := new(WatchTimeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *liveSplitServiceClient) WatchTimerPhase(ctx context.Context, in *WatchTimerPhaseRequest, opts ...grpc.CallOption) (LiveSplitService_WatchTimerPhaseClient, error) {
	stream, err := c.cc.NewStream(ctx, &LiveSplitService_ServiceDesc.Streams[1], "/livesplit.connect.v1.LiveSplitService/WatchTimerPhase", opts...)
	if err != nil {
		return nil, err
	}
	x := &liveSplitServiceWatchTimerPhaseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LiveSplitService_WatchTimerPhaseClient interface {
	Recv() (*WatchTimerPhaseResponse, error)
	grpc.ClientStream
}

type liveSplitServiceWatchTimerPhaseClient struct {
	grpc.ClientStream
}

func (x *liveSplitServiceWatchTimerPhaseClient) Recv() (*WatchTimerPhaseResponse, error) {
	m := new(WatchTimerPhaseResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *liveSplitServiceClient) WatchSplit(ctx context.Context, in *WatchSplitRequest, opts ...grpc.CallOption) (LiveSplitService_WatchSplitClient, error) {
	stream, err := c.cc.NewStream(ctx, &LiveSplitService_ServiceDesc.Streams[2], "/livesplit.connect.v1.LiveSplitService/WatchSplit", opts...)
	if err != nil {
		return nil, err
	}
	x := &liveSplitServiceWatchSplitClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LiveSplitService_WatchSplitClient interface {
	Recv() (*WatchSplitResponse, error)
	grpc.ClientStream
}

type liveSplitServiceWatchSplitClient struct {
	grpc.ClientStream
}

func (x *liveSplitServiceWatchSplitClient) Recv() (*WatchSplitResponse, error) {
	m := new(WatchSplitResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *liveSplitServiceClient) WatchRun(ctx context.Context, in *WatchRunRequest, opts ...grpc.CallOption) (LiveSplitService_WatchRunClient, error) {
	stream, err := c.cc.NewStream(ctx, &LiveSplitService_ServiceDesc.Streams[3], "/livesplit.connect.v1.LiveSplitService/WatchRun", opts...)
	if err != nil {
		return nil, err
	}
	x := &liveSplitServiceWatchRunClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LiveSplitService_WatchRunClient interface {
	Recv() (*WatchRunResponse, error)
	grpc.ClientStream
}

type liveSplitServiceWatchRunClient struct {
	grpc.ClientStream
}

func (x *liveSplitServiceWatchRunClient) Recv() (*WatchRunResponse, error) {
	m := new(WatchRunResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// LiveSplitServiceServer is the server API for LiveSplitService service.
// All implementations must embed UnimplementedLiveSplitServiceServer
// for forward compatibility
type LiveSplitServiceServer interface {
	// StartOrSplit starts the timer if not start, or split current segment is the timer is started.
	// If the timer is paused, nothing happens.
	StartOrSplit(context.Context, *StartOrSplitRequest) (*StartOrSplitResponse, error)
	// SkipSplit skip current split and move timer to the next segment.
	// If the timer is not started, this command does nothing.
	SkipSplit(context.Context, *SkipSplitRequest) (*SkipSplitResponse, error)
	// UnSplit undoes current split and move timer to the previous segment.
	// If the timer is not started, this command does nothing.
	UnSplit(context.Context, *UnSplitRequest) (*UnSplitResponse, error)
	// Pause toogles pause on the timer (pause if started, unpause if paused).
	// If the timer is not started, this command does nothing.
	Pause(context.Context, *PauseRequest) (*PauseResponse, error)
	// Reset the timer and all current segment splits.
	Reset(context.Context, *ResetRequest) (*ResetResponse, error)
	// GetTime returns the current time information of the timer.
	GetTime(context.Context, *GetTimeRequest) (*GetTimeResponse, error)
	// GetCurrentSegment returns the current segment info.
	GetCurrentSegment(context.Context, *GetCurrentSegmentRequest) (*GetCurrentSegmentResponse, error)
	// FindSegment searchs for a specific segment in the segment list of the run.
	FindSegment(context.Context, *FindSegmentRequest) (*FindSegmentResponse, error)
	// ListSegment returns all segment info of the run.
	ListSegment(context.Context, *ListSegmentRequest) (*ListSegmentResponse, error)
	// GetRun returns all information of the run.
	GetRun(context.Context, *GetRunRequest) (*GetRunResponse, error)
	// GetCurrentComparisonMethod returns the current select comparaison method in LiveSplit.
	GetCurrentComparisonMethod(context.Context, *GetCurrentComparisonMethodRequest) (*GetCurrentComparisonMethodResponse, error)
	// GetCurrentTimerPhase returns the current timer phase in LiveSplit
	GetCurrentTimerPhase(context.Context, *GetCurrentTimerPhaseRequest) (*GetCurrentTimerPhaseResponse, error)
	// GetCurrentTimingMethod returns the current selected timing method in LiveSplit.
	GetCurrentTimingMethod(context.Context, *GetCurrentTimingMethodRequest) (*GetCurrentTimingMethodResponse, error)
	// WatchTime streams regularly current run time to the client.
	// The frequency of updates is specified in the request.
	WatchTime(*WatchTimeRequest, LiveSplitService_WatchTimeServer) error
	// WatchTimerPhase streams change events regarding timer phase to the client.
	WatchTimerPhase(*WatchTimerPhaseRequest, LiveSplitService_WatchTimerPhaseServer) error
	// WatchSplit streams change events regarding timer phase to the client.
	WatchSplit(*WatchSplitRequest, LiveSplitService_WatchSplitServer) error
	// WatchRun streams change events regarding selected run (ie when another run file is loaded) to the client.
	WatchRun(*WatchRunRequest, LiveSplitService_WatchRunServer) error
	mustEmbedUnimplementedLiveSplitServiceServer()
}

// UnimplementedLiveSplitServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLiveSplitServiceServer struct {
}

func (UnimplementedLiveSplitServiceServer) StartOrSplit(context.Context, *StartOrSplitRequest) (*StartOrSplitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartOrSplit not implemented")
}
func (UnimplementedLiveSplitServiceServer) SkipSplit(context.Context, *SkipSplitRequest) (*SkipSplitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SkipSplit not implemented")
}
func (UnimplementedLiveSplitServiceServer) UnSplit(context.Context, *UnSplitRequest) (*UnSplitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnSplit not implemented")
}
func (UnimplementedLiveSplitServiceServer) Pause(context.Context, *PauseRequest) (*PauseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pause not implemented")
}
func (UnimplementedLiveSplitServiceServer) Reset(context.Context, *ResetRequest) (*ResetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reset not implemented")
}
func (UnimplementedLiveSplitServiceServer) GetTime(context.Context, *GetTimeRequest) (*GetTimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTime not implemented")
}
func (UnimplementedLiveSplitServiceServer) GetCurrentSegment(context.Context, *GetCurrentSegmentRequest) (*GetCurrentSegmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentSegment not implemented")
}
func (UnimplementedLiveSplitServiceServer) FindSegment(context.Context, *FindSegmentRequest) (*FindSegmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindSegment not implemented")
}
func (UnimplementedLiveSplitServiceServer) ListSegment(context.Context, *ListSegmentRequest) (*ListSegmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSegment not implemented")
}
func (UnimplementedLiveSplitServiceServer) GetRun(context.Context, *GetRunRequest) (*GetRunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRun not implemented")
}
func (UnimplementedLiveSplitServiceServer) GetCurrentComparisonMethod(context.Context, *GetCurrentComparisonMethodRequest) (*GetCurrentComparisonMethodResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentComparisonMethod not implemented")
}
func (UnimplementedLiveSplitServiceServer) GetCurrentTimerPhase(context.Context, *GetCurrentTimerPhaseRequest) (*GetCurrentTimerPhaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentTimerPhase not implemented")
}
func (UnimplementedLiveSplitServiceServer) GetCurrentTimingMethod(context.Context, *GetCurrentTimingMethodRequest) (*GetCurrentTimingMethodResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentTimingMethod not implemented")
}
func (UnimplementedLiveSplitServiceServer) WatchTime(*WatchTimeRequest, LiveSplitService_WatchTimeServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchTime not implemented")
}
func (UnimplementedLiveSplitServiceServer) WatchTimerPhase(*WatchTimerPhaseRequest, LiveSplitService_WatchTimerPhaseServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchTimerPhase not implemented")
}
func (UnimplementedLiveSplitServiceServer) WatchSplit(*WatchSplitRequest, LiveSplitService_WatchSplitServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchSplit not implemented")
}
func (UnimplementedLiveSplitServiceServer) WatchRun(*WatchRunRequest, LiveSplitService_WatchRunServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchRun not implemented")
}
func (UnimplementedLiveSplitServiceServer) mustEmbedUnimplementedLiveSplitServiceServer() {}

// UnsafeLiveSplitServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LiveSplitServiceServer will
// result in compilation errors.
type UnsafeLiveSplitServiceServer interface {
	mustEmbedUnimplementedLiveSplitServiceServer()
}

func RegisterLiveSplitServiceServer(s grpc.ServiceRegistrar, srv LiveSplitServiceServer) {
	s.RegisterService(&LiveSplitService_ServiceDesc, srv)
}

func _LiveSplitService_StartOrSplit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartOrSplitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveSplitServiceServer).StartOrSplit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/livesplit.connect.v1.LiveSplitService/StartOrSplit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveSplitServiceServer).StartOrSplit(ctx, req.(*StartOrSplitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveSplitService_SkipSplit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SkipSplitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveSplitServiceServer).SkipSplit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/livesplit.connect.v1.LiveSplitService/SkipSplit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveSplitServiceServer).SkipSplit(ctx, req.(*SkipSplitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveSplitService_UnSplit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnSplitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveSplitServiceServer).UnSplit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/livesplit.connect.v1.LiveSplitService/UnSplit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveSplitServiceServer).UnSplit(ctx, req.(*UnSplitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveSplitService_Pause_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveSplitServiceServer).Pause(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/livesplit.connect.v1.LiveSplitService/Pause",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveSplitServiceServer).Pause(ctx, req.(*PauseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveSplitService_Reset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveSplitServiceServer).Reset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/livesplit.connect.v1.LiveSplitService/Reset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveSplitServiceServer).Reset(ctx, req.(*ResetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveSplitService_GetTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveSplitServiceServer).GetTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/livesplit.connect.v1.LiveSplitService/GetTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveSplitServiceServer).GetTime(ctx, req.(*GetTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveSplitService_GetCurrentSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrentSegmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveSplitServiceServer).GetCurrentSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/livesplit.connect.v1.LiveSplitService/GetCurrentSegment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveSplitServiceServer).GetCurrentSegment(ctx, req.(*GetCurrentSegmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveSplitService_FindSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindSegmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveSplitServiceServer).FindSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/livesplit.connect.v1.LiveSplitService/FindSegment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveSplitServiceServer).FindSegment(ctx, req.(*FindSegmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveSplitService_ListSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSegmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveSplitServiceServer).ListSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/livesplit.connect.v1.LiveSplitService/ListSegment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveSplitServiceServer).ListSegment(ctx, req.(*ListSegmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveSplitService_GetRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveSplitServiceServer).GetRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/livesplit.connect.v1.LiveSplitService/GetRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveSplitServiceServer).GetRun(ctx, req.(*GetRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveSplitService_GetCurrentComparisonMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrentComparisonMethodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveSplitServiceServer).GetCurrentComparisonMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/livesplit.connect.v1.LiveSplitService/GetCurrentComparisonMethod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveSplitServiceServer).GetCurrentComparisonMethod(ctx, req.(*GetCurrentComparisonMethodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveSplitService_GetCurrentTimerPhase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrentTimerPhaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveSplitServiceServer).GetCurrentTimerPhase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/livesplit.connect.v1.LiveSplitService/GetCurrentTimerPhase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveSplitServiceServer).GetCurrentTimerPhase(ctx, req.(*GetCurrentTimerPhaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveSplitService_GetCurrentTimingMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrentTimingMethodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveSplitServiceServer).GetCurrentTimingMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/livesplit.connect.v1.LiveSplitService/GetCurrentTimingMethod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveSplitServiceServer).GetCurrentTimingMethod(ctx, req.(*GetCurrentTimingMethodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveSplitService_WatchTime_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchTimeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LiveSplitServiceServer).WatchTime(m, &liveSplitServiceWatchTimeServer{stream})
}

type LiveSplitService_WatchTimeServer interface {
	Send(*WatchTimeResponse) error
	grpc.ServerStream
}

type liveSplitServiceWatchTimeServer struct {
	grpc.ServerStream
}

func (x *liveSplitServiceWatchTimeServer) Send(m *WatchTimeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _LiveSplitService_WatchTimerPhase_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchTimerPhaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LiveSplitServiceServer).WatchTimerPhase(m, &liveSplitServiceWatchTimerPhaseServer{stream})
}

type LiveSplitService_WatchTimerPhaseServer interface {
	Send(*WatchTimerPhaseResponse) error
	grpc.ServerStream
}

type liveSplitServiceWatchTimerPhaseServer struct {
	grpc.ServerStream
}

func (x *liveSplitServiceWatchTimerPhaseServer) Send(m *WatchTimerPhaseResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _LiveSplitService_WatchSplit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchSplitRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LiveSplitServiceServer).WatchSplit(m, &liveSplitServiceWatchSplitServer{stream})
}

type LiveSplitService_WatchSplitServer interface {
	Send(*WatchSplitResponse) error
	grpc.ServerStream
}

type liveSplitServiceWatchSplitServer struct {
	grpc.ServerStream
}

func (x *liveSplitServiceWatchSplitServer) Send(m *WatchSplitResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _LiveSplitService_WatchRun_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchRunRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LiveSplitServiceServer).WatchRun(m, &liveSplitServiceWatchRunServer{stream})
}

type LiveSplitService_WatchRunServer interface {
	Send(*WatchRunResponse) error
	grpc.ServerStream
}

type liveSplitServiceWatchRunServer struct {
	grpc.ServerStream
}

func (x *liveSplitServiceWatchRunServer) Send(m *WatchRunResponse) error {
	return x.ServerStream.SendMsg(m)
}

// LiveSplitService_ServiceDesc is the grpc.ServiceDesc for LiveSplitService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LiveSplitService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "livesplit.connect.v1.LiveSplitService",
	HandlerType: (*LiveSplitServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartOrSplit",
			Handler:    _LiveSplitService_StartOrSplit_Handler,
		},
		{
			MethodName: "SkipSplit",
			Handler:    _LiveSplitService_SkipSplit_Handler,
		},
		{
			MethodName: "UnSplit",
			Handler:    _LiveSplitService_UnSplit_Handler,
		},
		{
			MethodName: "Pause",
			Handler:    _LiveSplitService_Pause_Handler,
		},
		{
			MethodName: "Reset",
			Handler:    _LiveSplitService_Reset_Handler,
		},
		{
			MethodName: "GetTime",
			Handler:    _LiveSplitService_GetTime_Handler,
		},
		{
			MethodName: "GetCurrentSegment",
			Handler:    _LiveSplitService_GetCurrentSegment_Handler,
		},
		{
			MethodName: "FindSegment",
			Handler:    _LiveSplitService_FindSegment_Handler,
		},
		{
			MethodName: "ListSegment",
			Handler:    _LiveSplitService_ListSegment_Handler,
		},
		{
			MethodName: "GetRun",
			Handler:    _LiveSplitService_GetRun_Handler,
		},
		{
			MethodName: "GetCurrentComparisonMethod",
			Handler:    _LiveSplitService_GetCurrentComparisonMethod_Handler,
		},
		{
			MethodName: "GetCurrentTimerPhase",
			Handler:    _LiveSplitService_GetCurrentTimerPhase_Handler,
		},
		{
			MethodName: "GetCurrentTimingMethod",
			Handler:    _LiveSplitService_GetCurrentTimingMethod_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchTime",
			Handler:       _LiveSplitService_WatchTime_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchTimerPhase",
			Handler:       _LiveSplitService_WatchTimerPhase_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchSplit",
			Handler:       _LiveSplitService_WatchSplit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchRun",
			Handler:       _LiveSplitService_WatchRun_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "livesplit/connect/v1/livesplit.proto",
}
